## 1. users, relations RLS 끼리 서로 바라봐서 recursive 일어남
1. user_map 테이블 생성
    - user_id, auth_id 저장
2. user_map 테이블엔 RLS 안 걸고, users, relations 등에서 필요할 때 해당 테이블 바라보게 해 recursive 제거
3. user_map 테이블은 직접 바라볼 수 없고, public.is_me_user_id(target_user_id bigint) 라는 함수를 통해서만 접근 가능하게 함.
    - 보안을 위해

```sql
-- “이 user_id가 나(현재 로그인자)인가?” 헬퍼 함수
CREATE OR REPLACE FUNCTION public.is_me_user_id(target_user_id bigint)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
    SELECT EXISTS (
    SELECT 1
    FROM public.user_map m
    WHERE m.user_id = target_user_id
        AND m.auth_user_id = auth.uid()
    );
$$;

ALTER FUNCTION public.is_me_user_id(bigint) OWNER TO postgres;
GRANT EXECUTE ON FUNCTION public.is_me_user_id(bigint) TO authenticated;

-- relations RLS를 함수 호출로 교체
DROP POLICY IF EXISTS "parent or child can view relations" ON public.relations;
CREATE POLICY "parent or child can view relations"
ON public.relations
FOR SELECT TO authenticated
USING (
    public.is_me_user_id(relations.parent_id)
    OR
    public.is_me_user_id(relations.child_id)
);

-- users RLS도 함수로(‘내게 온 요청의 부모’)
DROP POLICY IF EXISTS "Users: parent of my incoming relation" ON public.users;
CREATE POLICY "Users: parent of my incoming relation"
ON public.users
FOR SELECT TO authenticated
USING (
    EXISTS (
    SELECT 1
    FROM public.relations r
    WHERE r.parent_id = users.id
        AND public.is_me_user_id(r.child_id)
        AND r.status IN ('PENDING','ACTIVE')
    )
);

-- user_map 보안 재확인 (직접 접근 차단 유지)
ALTER TABLE public.user_map DISABLE ROW LEVEL SECURITY;
REVOKE ALL ON public.user_map FROM authenticated, anon, public;
```
<br><br>

## 2. users에 user 추가 시, balances에 insert 트리거 생성 (바로 밑 수정사항떄매 DROP 함.)

```sql
-- 함수 생성
CREATE OR REPLACE FUNCTION public.create_initial_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- balances에 기본 잔액 200 추가
    INSERT INTO public.balances (user_id, amount, updated_at)
    VALUES (NEW.id, 200, NOW());

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 트리거 생성
DROP TRIGGER IF EXISTS trg_create_initial_balance ON public.users;

CREATE TRIGGER trg_create_initial_balance
AFTER INSERT ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.create_initial_balance();
```

<br><br>

## 3. transactions → balance 자동 반영 & users 초기생성 → transactions 트리거

```sql
-- 기존 ENUM에 타입 추가
ALTER TYPE transaction_type ADD VALUE IF NOT EXISTS 'INITIAL_CREDIT';

-- 한 user당 INITIAL_CREDIT는 한 번만 허용
CREATE UNIQUE INDEX IF NOT EXISTS ux_tx_initial_credit_once
ON public.transactions (user_id)
WHERE type = 'INITIAL_CREDIT';

CREATE OR REPLACE FUNCTION public.apply_transaction_to_balance()
RETURNS TRIGGER AS $$
BEGIN
    -- balances 없으면 새로 만들고, 있으면 누적 업데이트
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.user_id, NEW.amount, now())
    ON CONFLICT (user_id)
    DO UPDATE SET
    balance = public.balances.balance + EXCLUDED.balance,
    updated_at = now();

    -- (선택) 음수 잔액 방지
    IF (SELECT balance FROM public.balances WHERE user_id = NEW.user_id) < 0 THEN
    RAISE EXCEPTION 'Balance would become negative for user %', NEW.user_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_apply_transaction_to_balance ON public.transactions;

CREATE TRIGGER trg_apply_transaction_to_balance
AFTER INSERT ON public.transactions
FOR EACH ROW
EXECUTE FUNCTION public.apply_transaction_to_balance();

CREATE OR REPLACE FUNCTION public.create_initial_credit_tx()
RETURNS TRIGGER AS $$
BEGIN
    -- 초기 지급 트랜잭션 생성 (balances는 위 트리거로 자동 반영됨)
    INSERT INTO public.transactions (
    user_id,
    type,
    amount,
    reference_type,
    reference_id,
    created_at
    )
    VALUES (
    NEW.id,
    'INITIAL_CREDIT',
    200,
    'SYSTEM',
    NULL,
    now()
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_create_initial_credit_tx ON public.users;

CREATE TRIGGER trg_create_initial_credit_tx
AFTER INSERT ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.create_initial_credit_tx();

```

<br><br>

## 4. 부모는 초기재화 200, 자식일 때는 0으로 들어가도록 트리거 수정

```sql
CREATE OR REPLACE FUNCTION public.create_initial_credit_tx()
RETURNS TRIGGER AS $$
BEGIN
    -- ✅ 부모(PARENT): INITIAL_CREDIT 트랜잭션 + balance=200
    IF NEW.role = 'PARENT'::user_role THEN
    INSERT INTO public.transactions (
        user_id, type, amount, reference_type, reference_id, created_at
    )
    VALUES (
        NEW.id, 'INITIAL_CREDIT', 200, 'SYSTEM', NULL, now()
    )
    ON CONFLICT (user_id) DO NOTHING;  -- 중복 방지

    -- ✅ 자식(CHILD): INITIAL_CREDIT 없음, balances에 0으로 row만 생성
    ELSIF NEW.role = 'CHILD'::user_role THEN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.id, 0, now())
    ON CONFLICT (user_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_create_initial_credit_tx ON public.users;

CREATE TRIGGER trg_create_initial_credit_tx
AFTER INSERT ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.create_initial_credit_tx();

```