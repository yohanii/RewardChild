## 1. 로그인 다시 안됨 & auth.users 다시 안만들어지는 문제

로그

```sql
1.
INSERT INTO "users" ("aud", "banned_until", "confirmation_sent_at", "confirmation_token", "created_at", "deleted_at", "email", "email_change", "email_change_confirm_status", "email_change_sent_at", "email_change_token_current", "email_change_token_new", "email_confirmed_at", "encrypted_password", "id", "instance_id", "invited_at", "is_anonymous", "is_sso_user", "last_sign_in_at", "phone", "phone_change", "phone_change_sent_at", "phone_change_token", "phone_confirmed_at", "raw_app_meta_data", "raw_user_meta_data", "reauthentication_sent_at", "reauthentication_token", "recovery_sent_at", "recovery_token", "role", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33)
"type \"user_role\" does not exist"

2.
deallocate "pgx_0"
"current transaction is aborted, commands ignored until end of transaction block"
```

원인

```sql
로그의 "type \"user_role\" does not exist"가 핵심이야.
auth.users에 INSERT될 때 → on_auth_user_created → public.handle_new_auth_user → public.users INSERT → 그 직후 네 AFTER INSERT ON public.users 트리거가 실행되는데, 트리거 함수 안에서 'PARENT'::user_role 같은 스키마 미지정 enum 캐스트가 있어요. 이때 실행 컨텍스트가 auth에서 시작돼서 search_path에 public이 없으면 user_role 타입을 못 찾아 바로 실패 → 그다음 "current transaction is aborted"가 연쇄로 뜬 거예요.

해결 요약

트리거/함수에 SECURITY DEFINER + SET search_path = public 지정

enum은 반드시 스키마를 붙여서 캐스팅 (public.user_role)

또는 NEW.role::text = 'PARENT'처럼 text 비교로 회피
```

해결

1) 초기 지급/0원 생성 함수 (users INSERT용)

```sql
CREATE OR REPLACE FUNCTION public.create_initial_credit_tx()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    -- enum 비교: 스키마를 붙여서 캐스트
    IF NEW.role = 'PARENT'::public.user_role THEN
    INSERT INTO public.transactions (
        user_id, type, amount, reference_type, reference_id, created_at
    )
    VALUES (NEW.id, 'INITIAL_CREDIT', 200, 'SYSTEM', NULL, now())
    ON CONFLICT ON CONSTRAINT ux_tx_initial_credit_once DO NOTHING;

    ELSIF NEW.role = 'CHILD'::public.user_role THEN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.id, 0, now())
    ON CONFLICT (user_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$;

ALTER FUNCTION public.create_initial_credit_tx() OWNER TO postgres;

```

2) 트랜잭션 → 밸런스 반영 함수

```sql
CREATE OR REPLACE FUNCTION public.apply_transaction_to_balance()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.user_id, NEW.amount, now())
    ON CONFLICT (user_id)
    DO UPDATE SET
    balance   = public.balances.balance + EXCLUDED.balance,
    updated_at = now();

    IF (SELECT balance FROM public.balances WHERE user_id = NEW.user_id) < 0 THEN
    RAISE EXCEPTION 'Balance would become negative for user %', NEW.user_id;
    END IF;

    RETURN NEW;
END;
$$;

ALTER FUNCTION public.apply_transaction_to_balance() OWNER TO postgres;

```

**3) (권장) 역할 변경 시 보장용 UPDATE 트리거도 동일하게 수정**

```sql
CREATE OR REPLACE FUNCTION public.apply_initial_credit_on_role_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    IF NEW.role = 'PARENT'::public.user_role
        AND (OLD.role IS DISTINCT FROM 'PARENT'::public.user_role) THEN
    INSERT INTO public.transactions (user_id, type, amount, reference_type, reference_id, created_at)
    VALUES (NEW.id, 'INITIAL_CREDIT', 200, 'SYSTEM', NULL, now())
    ON CONFLICT ON CONSTRAINT ux_tx_initial_credit_once DO NOTHING;
    END IF;

    IF NEW.role = 'CHILD'::public.user_role
        AND (OLD.role IS DISTINCT FROM 'CHILD'::public.user_role) THEN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.id, 0, now())
    ON CONFLICT (user_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$;

ALTER FUNCTION public.apply_initial_credit_on_role_change() OWNER TO postgres;

```

4) 트리거 재설치(변경 사항 반영)

```sql
-- INSERT용
DROP TRIGGER IF EXISTS trg_create_initial_credit_tx ON public.users;
CREATE TRIGGER trg_create_initial_credit_tx
AFTER INSERT ON public.users
FOR EACH ROW
EXECUTE FUNCTION public.create_initial_credit_tx();

-- UPDATE(역할 변경)용 — 쓰고 있다면 유지/설치
DROP TRIGGER IF EXISTS trg_user_role_change ON public.users;
CREATE TRIGGER trg_user_role_change
AFTER UPDATE OF role ON public.users
FOR EACH ROW
WHEN (OLD.role IS DISTINCT FROM NEW.role)
EXECUTE FUNCTION public.apply_initial_credit_on_role_change();

-- transactions → balances
DROP TRIGGER IF EXISTS trg_apply_transaction_to_balance ON public.transactions;
CREATE TRIGGER trg_apply_transaction_to_balance
AFTER INSERT ON public.transactions
FOR EACH ROW
EXECUTE FUNCTION public.apply_transaction_to_balance();

```
<br><br>

## 2. 부모일때만, role 안바뀌는 문제

원인

transactions에 있는 건 부분 유니크 인덱스

`(WHERE type='INITIAL_CREDIT')`인데,

함수에서는 `ON CONFLICT (user_id) DO NOTHING`

만 써서 부분 인덱스와 매칭을 못 하고 실패합니다. 

부분 유니크 인덱스를 쓰려면 `ON CONFLICT`에도 동일한 predicate 를 명시해야 해요.

해결

```sql
-- 1) users INSERT 시: 부모 200 / 자녀 0-row
CREATE OR REPLACE FUNCTION public.create_initial_credit_tx()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    IF NEW.role = 'PARENT'::public.user_role THEN
    INSERT INTO public.transactions (user_id, type, amount, reference_type, reference_id, created_at)
    VALUES (NEW.id, 'INITIAL_CREDIT', 200, NULL, NULL, now())
    ON CONFLICT (user_id) WHERE (type = 'INITIAL_CREDIT'::transaction_type) DO NOTHING;

    ELSIF NEW.role = 'CHILD'::public.user_role THEN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.id, 0, now())
    ON CONFLICT (user_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$;

ALTER FUNCTION public.create_initial_credit_tx() OWNER TO postgres;

```

```sql
-- 2) role 변경 시에도 1회 보장
CREATE OR REPLACE FUNCTION public.apply_initial_credit_on_role_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    IF NEW.role = 'PARENT'::public.user_role
        AND (OLD.role IS DISTINCT FROM 'PARENT'::public.user_role) THEN
    INSERT INTO public.transactions (user_id, type, amount, reference_type, reference_id, created_at)
    VALUES (NEW.id, 'INITIAL_CREDIT', 200, NULL, NULL, now())
    ON CONFLICT (user_id) WHERE (type = 'INITIAL_CREDIT'::transaction_type) DO NOTHING;
    END IF;

    IF NEW.role = 'CHILD'::public.user_role
        AND (OLD.role IS DISTINCT FROM 'CHILD'::public.user_role) THEN
    INSERT INTO public.balances (user_id, balance, updated_at)
    VALUES (NEW.id, 0, now())
    ON CONFLICT (user_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$;

ALTER FUNCTION public.apply_initial_credit_on_role_change() OWNER TO postgres;

```